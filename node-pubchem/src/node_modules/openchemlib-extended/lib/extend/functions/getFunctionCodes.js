'use strict';

module.exports = function (OCL) {
  return function getFunctionCodes() {
    var molecule = this.getCompactCopy();
    var atoms = molecule.getAtomsInfo();
    for (var i = 0; i < molecule.getAllAtoms(); i++) {
      var atom = atoms[i];
      atom.i = i;
      atom.mapNo = molecule.getAtomMapNo(i);
      atom.links = []; // we will store connected atoms of broken bonds
    }

    var bonds = [];
    for (var _i = 0; _i < molecule.getAllBonds(); _i++) {
      var bond = {};
      bonds.push(bond);
      bond.i = _i;
      bond.order = molecule.getBondOrder(_i);
      bond.atom1 = molecule.getBondAtom(0, _i);
      bond.atom2 = molecule.getBondAtom(1, _i);
      bond.type = molecule.getBondType(_i);
      bond.isAromatic = molecule.isAromaticBond(_i);

      if (!bond.isAromatic && molecule.getBondTypeSimple(_i) === 1 && molecule.getAtomicNo(bond.atom1) === 6 && molecule.getAtomicNo(bond.atom2) === 6 && (atoms[bond.atom1].extra.cnoHybridation === 3 || atoms[bond.atom2].extra.cnoHybridation === 3)) {
        bond.selected = true;
        atoms[bond.atom1].links.push(bond.atom2);
        atoms[bond.atom2].links.push(bond.atom1);
      }
    }

    var brokenMolecule = molecule.getCompactCopy();
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = bonds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _bond = _step.value;

        if (_bond.selected) {
          brokenMolecule.markBondForDeletion(_bond.i);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    brokenMolecule.deleteMarkedAtomsAndBonds();
    var fragmentMap = [];
    var nbFragments = brokenMolecule.getFragmentNumbers(fragmentMap);

    var results = {};

    var _loop = function _loop(_i2) {
      result = {};

      result.atomMap = [];
      includeAtom = fragmentMap.map(function (id) {
        return id === _i2;
      });
      fragment = new OCL.Molecule();
      atomMap = [];

      brokenMolecule.copyMoleculeByAtoms(fragment, includeAtom, false, atomMap);
      parent = fragment.getCompactCopy();

      parent.setFragment(true);
      // we will remove the hydrogens of the broken carbon
      for (var j = 0; j < atomMap.length; j++) {
        if (atomMap[j] > -1) {
          //                var numberDeletedHydrogens = 0;
          if (atoms[j].links.length > 0) {
            for (var k = 0; k < atoms[j].links.length; k++) {
              if (parent.getAtomicNo(atoms[j].links[k]) === 1) {
                //                           numberDeletedHydrogens++;
                fragment.deleteAtom(atoms[j].links[k]);
              }
            }
          }
          fragment.ensureHelperArrays(OCL.Molecule.cHelperBitNeighbours);
          // we will allow any substitution on sp3 hydrogens
          // that is at an extremety (only one connection)

          if (atoms[j].atomicNo === 6 && fragment.getConnAtoms(atomMap[j]) > 1) {
            if (atoms[j].allHydrogens !== 0) parent.setAtomQueryFeature(atomMap[j], OCL.Molecule.cAtomQFNot0Hydrogen, true);
            if (atoms[j].allHydrogens !== 1) parent.setAtomQueryFeature(atomMap[j], OCL.Molecule.cAtomQFNot1Hydrogen, true);
            if (atoms[j].allHydrogens !== 2) parent.setAtomQueryFeature(atomMap[j], OCL.Molecule.cAtomQFNot2Hydrogen, true);
            if (atoms[j].allHydrogens !== 3) parent.setAtomQueryFeature(atomMap[j], OCL.Molecule.cAtomQFNot3Hydrogen, true);
          }
          if (atoms[j].atomicNo !== 6) {
            parent.setAtomQueryFeature(atomMap[j], OCL.Molecule.cAtomQFNoMoreNeighbours, true);
          }
        }
      }

      result.parent = parent.getIDCode();
      fragment.setFragment(false); // required for small molecules like methanol

      // we will add some R groups at the level of the broken bonds
      for (var _j = 0; _j < atomMap.length; _j++) {
        if (atomMap[_j] > -1) {
          result.atomMap.push(_j);
          if (atoms[_j].links.length > 0) {
            for (var _k = 0; _k < atoms[_j].links.length; _k++) {
              rGroup = fragment.addAtom(154);
              x = molecule.getAtomX(atoms[_j].links[_k]);
              y = molecule.getAtomY(atoms[_j].links[_k]);

              fragment.setAtomX(rGroup, x);
              fragment.setAtomY(rGroup, y);
              fragment.addBond(atomMap[_j], rGroup, 1);
            }
          }
        }
      }
      result.idCode = fragment.getIDCode();

      if (results[result.idCode]) {
        results[result.idCode].atomMap = results[result.idCode].atomMap.concat(result.atomMap);
      } else {
        results[result.idCode] = {
          atomMap: result.atomMap,
          idCode: result.idCode
        };
      }

      if (results[result.parent]) {
        results[result.parent].atomMap = results[result.parent].atomMap.concat(result.atomMap);
      } else {
        results[result.parent] = {
          atomMap: result.atomMap,
          idCode: result.parent
        };
      }
    };

    for (var _i2 = 0; _i2 < nbFragments; _i2++) {
      var result;
      var includeAtom;
      var fragment;
      var atomMap;
      var parent;
      var rGroup;
      var x;
      var y;

      _loop(_i2);
    }

    // fragments should be unique
    var fragments = [];
    Object.keys(results).forEach(function (key) {
      fragments.push(results[key]);
    });
    return fragments;
  };
};